/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package PIS_HU1;

import org.junit.Assert;
import org.junit.Test;
import static org.junit.Assert.*;

public class AppTest {
  private GameEngine game = new GameEngine();

  //Es wird geschaut, ob das Board bei Spielbeginn leer ist
  @Test
  public void testEmptyBoard() {
     Assert.assertArrayEquals("Das Spielfeld ist nicht leer, obwohl das Spiel neu gestartet wurde",game.getPlayerBoard(), new long[] {0L, 0L});
  }

  //Es wird geprüft, ob der Zug korrekt ausgeführt worden ist und dieser richtig gespeichert wird
  @Test
  public void testMove() {
    game.reset();
    game.makeMove(0);
    Assert.assertEquals("Der Zug wurde nicht richtig gespeichert","1", Long.toBinaryString(game.getPlayerBoard()[0]));
  }

  //es wird mehrere Züge geprüft (Warum geht es nicht mit noch mehr zügen)
  @Test
  public void testMoreMove(){
    game.makeMove(0);
    game.makeMove(2);
    game.makeMove(4);
    game.makeMove(1);
    game.makeMove(2);
    game.makeMove(0);
    Assert.assertEquals("Die Zuege wurden nicht korrekt gespeichert", "10000000000001000000000000001", Long.toBinaryString(game.getPlayerBoard()[0]));
  }

  //Es wird geprüft, ob der andere Spieler nach einem Zug dran ist
  @Test
  public void testPlayerTurn(){
    game.makeMove(0);
    Assert.assertEquals(, game.playerBoard[0]);
  }*/

  //es wird geprüft, ob eine Zeile schon voll ist
  @Test
  public void testFullCol(){
    game.makeMove(0);
    game.makeMove(0);
    game.makeMove(0);
    game.makeMove(0);
    game.makeMove(0);
    game.makeMove(0);
    game.makeMove(0);
    Assert.assertFalse("Die Spalte ist voll, trotzdem kann ein Stein gesetzt werden",game.isPlayable(0));
  }


  //Es wird ein Beispiel für einen horizontalen Sieg im Board gespeichert und dann die isWin Methode für horizontale Viererlinien getestet
  @Test
  public void testWin() {
    // 1000000100000010000001 horizontal win
    game.getPlayerBoard()[0] = Long.parseLong("1000000100000010000001", 2);
    assertTrue("Es gibt vier Steine in Reihe,isWin erkennt dies nicht",game.isWin(game.getPlayerBoard()[0]));
  }

  //Es wird ein Beispiel für einen diagonalen Sieg im Board gespeichert und dann die isWin Methode für horizontale Viererlinien getestet
  @Test
  public void testDiagonalWin(){
    //Beispiel für eine Bitkombination, wenn vier gelbe Steine diagonal in Reihe stehen
    game.playerBoard[0]=Long.parseLong("1000000111000000100000001",2);
    Assert.assertTrue("Es gibt vier Steine in Reihe,isWin erkennt dies nicht",game.isWin(game.playerBoard[0]));

  }

  //Es werden verschiedene Züge gespielt, die keinen Sieg ergeben und dann wird die isWin Methode geprüft, ob sie das erkennt
  @Test
  public void testIsNotAWin() {
    game.makeMove(6);
    game.makeMove(2);
    game.makeMove(1);
    game.makeMove(5);
    game.makeMove(4);
    assertFalse("Es gibt keine 4 Steine in Reihe, isWin ist fehlerhaft",game.isWin(game.playerBoard[1] | game.playerBoard[0]));
  }

  //Es wird geprüft, ob undoMove den Zug korrekt zurücknimmt
  @Test
  public void testUndoMove() {
    game.makeMove(1);
    game.undoMove();
    Assert.assertEquals(0L, game.playerBoard[0]);
  }

  // Es wird geprüft, ob isPlayable() für diese beispielhafte Eingabe den korrekten Wert ausgibt
  @Test
  public void isPlayable() {
    Assert.assertTrue(game.isPlayable(2));
  }

  @Test
  public void testIsLegal() {
    Assert.assertTrue(game.isLegal(game.playerBoard[0] | (1L << game.heightCol[5])));
    Assert.assertTrue(game.isLegal(game.playerBoard[1] | (1L << game.heightCol[5])));
  }

  //Es wird geprüft, ob das Spiel korrekt zurückgesetzt wird
  @Test
  public void testReset() {
    game.makeMove(1);
    game.makeMove(5);
    game.reset();
    Assert.assertEquals(0L, game.playerBoard[0]);
    Assert.assertEquals(0L, game.playerBoard[1]);
  }

  @Test
  public void testListMove() {
    game.makeMove(1);
    Assert.assertNotEquals(null, game.listMoves());
  }

  //Prüft, ob die Methode simulatePlays auch wirklich Spiele simuliert
  @Test
  public void testSimulatePlays() {
    int[] i = {0, 0, 0};
    Assert.assertNotEquals(i, game.simulatePlays(game, 100));
  }

  /*Es wird ein Spiel simuliert, wo drei gelbe Steine, in der ersten Spalte, in einer Reihe sind.
  chooseBestMove muss jetzt erkennen, dass der nächstbeste Zug die Spalte 1 ist.
   */

  @Test
  public void testChooseBestMove() {
    // three yellow stones are in col 0
    game.makeMove(0);
    game.makeMove(1);
    game.makeMove(0);
    game.makeMove(1);
    game.makeMove(0);
    Assert.assertEquals(0, game.chooseBestMove(game, 100));
  }

  //Es wird geprüft, ob das Spiel unentschieden ausgegangen ist
  @Test
  public void testDraw(){
    game.reset();
    int[] drawCol = {6,13,20,27,34,41,48};
    game.setHeightCol(drawCol); //heightCol prüft, ob man noch ein Stein in die Zeile setzen kann und wird hier auf den vollen Wert für alle Spalten gesetzt
    Assert.assertTrue("Test", game.listMoves().isEmpty()); //listMoves gibt die nächsten möglichen Züge aus


  }


}
